#' Train function for hill.climb method
#' 
#' @param learner [list of base learners]
#' @template arg_task
#' @param replace [\code{logical(1)}]
#' @param init [\code{integer(1)}] init >= 1
#' @param bagprob [\code{numeric(1)}] 0 < bagprob < 1
#' @param bagtime [\code{integer(1)}] bagtime >= 1
#' @param maxiter [\code{integer(1)}] maxiter >= 1
#' @param tolerance [\code{numeric(1)}] small numeric value.
#' @template arg_measures
#' @export


hillclimbBaseLearners = function(learner, task, replace = TRUE, init = 1, bagprob = 1, bagtime = 1,
  maxiter = NULL, tolerance = 1e-8, metric = NULL, ...) {
  # check, defaults
  assertFlag(replace)
  assertInt(init, lower = 1, upper = length(learner$base.learners)) #807
  assertNumber(bagprob, lower = 0, upper = 1)
  assertInt(bagtime, lower = 1)
  if (is.null(metric)) metric = getDefaultMeasure(task)
  assertClass(metric, "Measure")
  if (is.null(maxiter)) maxiter = length(learner$base.learners)
  assertInt(maxiter, lower = 1)
  assertNumber(tolerance)
  
  # setup
  id = learner$id
  save.on.disc = learner$save.on.disc
  td = getTaskDescription(task)
  type = getPreciseTaskType(task) # "regr", "classif", "multiclassif"
  bls = learner$base.learners
  bls.names = names(bls)
  # check
  if (type != "regr") {
    if (any(extractSubList(bls, "predict.type") == "response"))
      stop("Hill climbing algorithm only takes probability predict type for classification.")
  }
  
  # resampling, train (parallelMap)
  rin = makeResampleInstance(learner$resampling, task = task)
  parallelLibrary("mlr", master = FALSE, level = "mlr.stacking", show.info = FALSE)
  exportMlrOptions(level = "mlr.stacking")
  show.info = getMlrOption("show.info")
  results = parallelMap(doTrainResample, bls, more.args = list(task, rin, 
      measures = metric, show.info, id, save.on.disc), 
      impute.error = function(x) x, level = "mlr.stacking")
  
  base.models = lapply(results, function(x) x[["base.models"]])
  resres = lapply(results, function(x) x[["resres"]])
  pred.list = lapply(resres, function(x) x[["pred"]])
  bls.performance = sapply(resres, function(x) x$aggr) 

  names(base.models) = bls.names
  names(resres) = bls.names
  names(pred.list) = bls.names
  names(bls.performance) = bls.names # this will not be removed below!
  
  ## Remove FailureModels which would occur problems later #FIXME!?
  ##broke.idx.bm = which(unlist(lapply(base.models, function(x) any(class(x) == "FailureModel"))))
  #broke.idx.pl = which(unlist(lapply(pred.list, function(x) anyNA(x$data))))# FIXME?!
  #broke.idx.rr = which(unlist(lapply(resres, function(x) is.na(x$aggr[1]))))
  ##broke.idx = unique(c(broke.idx.bm, broke.idx.rr, broke.idx.pl))
  #broke.idx = unique(c(broke.idx.rr, broke.idx.pl))
  #if (length(broke.idx) > 0) {
  #  messagef("Base Learner %s is broken and will be removed\n", names(bls)[broke.idx])
  #  resres = resres[-broke.idx]
  #  #pred.data = pred.data[-broke.idx]
  #  base.models = base.models[-broke.idx]
  #  pred.list = pred.list[-broke.idx]
  #}

  ensel = applyEnsembleSelection(pred.list = pred.list,
    bls.performance = bls.performance, parset = list(replace = replace, 
    init = init, bagprob = bagprob, bagtime = bagtime, maxiter = maxiter, 
    metric = metric, tolerance = tolerance))
  
  # return
  list(method = "hill.climb", base.models = base.models, super.model = NULL,
    pred.train = pred.list, bls.performance = bls.performance, 
    weights = ensel$weights, freq = ensel$freq, freq.list = ensel$freq.list)
}




#' Ensemble selection algorithm
#' 
#' @param pred.list A named (!) list of predictions
#' @param bls.performance Named vector of performance results fron training (note that this should be results from resampled predictions to overcome overfitting issues.)
#' @param parset list of parameters. See /code{/{link{makeStackedLearner}}}.
#' @references Caruana, Rich, et al. "Ensemble selection from libraries of models." 
#'   Proceedings of the twenty-first international conference on Machine learning. 
#'   ACM, 2004. \url{http://www.cs.cornell.edu/~caruana/ctp/ct.papers/caruana.icml04.icdm06long.pdf}
#' @export

applyEnsembleSelection = function(pred.list = pred.list, bls.performance = bls.performance, parset = list(replace = TRUE, 
  init = 1, bagprob = 1, bagtime = 1, maxiter = NULL, tolerance = 1e-8, metric = NULL)) {
  # check
  assertClass(parset, "list")
  bls.names = names(pred.list)
  bls.length = length(pred.list)
  
  # FIXME: Need defaults. should be nicer
  if (is.null(parset$replace)) parset$replace = TRUE
  if (is.null(parset$init)) parset$init = 1
  if (is.null(parset$bagprob)) parset$bagprob = 0.5
  if (is.null(parset$bagtime)) parset$bagtime = 20
  if (is.null(parset$metric)) parset$metric = getDefaultMeasure(pred.list[[1]]$task.desc)
  if (is.null(parset$maxiter)) parset$maxiter = bls.length
  if (is.null(parset$tolerance)) parset$tolerance = 1e-8
    
  #FIXME: neeeded!? or is parset$bar ok!?  
  replace = parset$replace
  init = parset$init
  bagprob = parset$bagprob
  bagtime = parset$bagtime
  maxiter = parset$maxiter
  metric = parset$metric
  tolerance = parset$tolerance
  
  # setup
  m = bls.length
  freq = rep(0, m)
  names(freq) = bls.names
  freq.list = vector("list", bagtime)
  
  # outer loop (bagging iterations)
  for (bagind in seq_len(bagtime)) {
    # bagging of models
    bagsize = ceiling(m * bagprob)
    bagmodel = sample(1:m, bagsize)
    
    # Initial selection of strongest learners
    inds.init = NULL
    inds.selected = NULL
    sel.algo = NULL
    single.scores = rep(ifelse(metric$minimize, Inf, -Inf), m)
    
    for (i in bagmodel) { #FIXME use apply
      single.scores[i] = bls.performance[i] #resres[[i]]$aggr
    }
    if (metric$minimize) { # FIXME use orderScore
      inds.init = order(single.scores)[1:init]
    } else {
      inds.init = rev(order(single.scores))[1:init] 
    }
    freq[inds.init] = freq[inds.init] + 1  
    
    current.pred.list = pred.list[inds.init]
    current.pred = aggregatePredictions(current.pred.list, pL = FALSE)
    bench.score = metric$fun(pred = current.pred)
    
    inds.selected = inds.init
    
    # inner loop
    for (i in seq_along(maxiter)) {
      temp.score = rep(ifelse(metric$minimize, Inf, -Inf), m)
      for (i in bagmodel) {
        temp.pred.list = append(current.pred.list, pred.list[i])
        aggr.pred = aggregatePredictions(temp.pred.list, pL = FALSE)
        temp.score[i] = metric$fun(pred = aggr.pred)
      }
      # order scores
      if (metric$minimize) { #FIXME use orderScore
        inds.ordered = order(temp.score)
      } else {
        inds.ordered  = rev(order(temp.score)) 
      }
      # identify best one
      if (!replace) {
        best.ind = setdiff(inds.ordered, inds.selected)[1]
      } else {
        best.ind = inds.ordered[1]
      }
      # take the best ones score
      new.score = temp.score[best.ind]
      # check if new ensemble improves overall performance
      if (bench.score - new.score < tolerance) {
        break() # break inner loop 
      } else {
        current.pred.list = append(current.pred.list, pred.list[best.ind])
        current.pred = aggregatePredictions(current.pred.list, pL = FALSE)
        freq[best.ind] = freq[best.ind] + 1
        inds.selected = c(inds.selected, best.ind)
        bench.score = new.score
      }
    } 
    # freq.list lists names of all selected bls in each bagging iteration
    sel.algo = bls.names[inds.selected]
    freq.list[[bagind]] = sel.algo
  }
  weights = freq/sum(freq) #TODO: drop in future?
  # return
  list(freq = freq, freq.list = freq.list, weights = weights)
}